# MESI_Two_Level_L1Cache.sm

# Define the machine type and name
machine(MachineType:L1Cache, "MESI Directory L1 Cache CMP")
 : Sequencer * sequencer;  # Pointer to the sequencer
   CacheMemory * L1Icache; # L1 Instruction Cache
   CacheMemory * L1Dcache; # L1 Data Cache
   RubyPrefetcher * prefetcher; # Prefetcher
   int l2_select_num_bits;
   Cycles l1_request_latency := 2;  # L1 request latency in cycles
   Cycles l1_response_latency := 2; # L1 response latency in cycles
   Cycles to_l2_latency := 1;       # Latency to L2 cache
   bool send_evictions;
   bool enable_prefetch := "False"; # Prefetch disabled by default

   # Message Queues
   # From this node's L1 cache TO the network

   # Request queue from L1 to L2
   MessageBuffer * requestFromL1Cache, network="To", virtual_network="0",
        vnet_type="request";

   # Response queue from L1 to L2
   MessageBuffer * responseFromL1Cache, network="To", virtual_network="1",
        vnet_type="response";

   # Unblock queue from L1 to L2
   MessageBuffer * unblockFromL1Cache, network="To", virtual_network="2",
        vnet_type="unblock";

   # To this node's L1 cache FROM the network
   # Request queue from L2 to L1
   MessageBuffer * requestToL1Cache, network="From", virtual_network="2",
        vnet_type="request";

   # Response queue from L2 to L1
   MessageBuffer * responseToL1Cache, network="From", virtual_network="1",
        vnet_type="response";

  # Request Buffer for prefetches
  MessageBuffer * optionalQueue;

  # Buffer for requests generated by the processor core
  MessageBuffer * mandatoryQueue;

# State declarations
{
  state_declaration(State, desc="Cache states", default="L1Cache_State_I") {
    # Base states
    NP, AccessPermission:Invalid, desc="Not present in either cache";
    I, AccessPermission:Invalid, desc="a L1 cache entry Idle";
    S, AccessPermission:Read_Only, desc="a L1 cache entry Shared";
    E, AccessPermission:Read_Only, desc="a L1 cache entry Exclusive";
    M, AccessPermission:Read_Write, desc="a L1 cache entry Modified", format="!b";

    # Transient States
    IS, AccessPermission:Busy, desc="L1 idle, issued GETS, have not seen response yet";
    IM, AccessPermission:Busy, desc="L1 idle, issued GETX, have not seen response yet";
    SM, AccessPermission:Read_Only, desc="L1 idle, issued GETX, have not seen response yet";
    IS_I, AccessPermission:Busy, desc="L1 idle, issued GETS, saw Inv before data because directory doesn't block on GETS hit";

    M_I, AccessPermission:Busy, desc="L1 replacing, waiting for ACK";
    SINK_WB_ACK, AccessPermission:Busy, desc="This is to sink WB_Acks from L2";

    # Transient States for prefetching
    PF_IS, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
    PF_IM, AccessPermission:Busy, desc="Issued GETX, have not seen response yet";
    PF_SM, AccessPermission:Busy, desc="Issued GETX, received data, waiting for acks";
    PF_IS_I, AccessPermission:Busy, desc="Issued GETs, saw inv before data";
  }

  # Event declarations
  enumeration(Event, desc="Cache events") {
    # L1 events
    Load,            desc="Load request from the home processor";
    Ifetch,          desc="I-fetch request from the home processor";
    Store,           desc="Store request from the home processor";

    Inv,           desc="Invalidate request from L2 bank";

    # internal generated request
    L1_Replacement,  desc="L1 Replacement", format="!r";
    PF_L1_Replacement,  desc="Prefetch L1 Replacement", format="!pr";

    # other requests
    Fwd_GETX,   desc="GETX from other processor";
    Fwd_GETS,   desc="GETS from other processor";
    Fwd_GET_INSTR,   desc="GET_INSTR from other processor";

    Data,       desc="Data for processor";
    Data_Exclusive,       desc="Data for processor";
    DataS_fromL1,       desc="data for GETS request, need to unblock directory";
    Data_all_Acks,       desc="Data for processor, all acks";

    Ack,        desc="Ack for processor";
    Ack_all,      desc="Last ack for processor";

    WB_Ack,        desc="Ack for replacement";

    PF_Load,    desc="load request from prefetcher";
    PF_Ifetch,  desc="instruction fetch request from prefetcher";
    PF_Store,   desc="exclusive load request from prefetcher";
  }

  # Structure definitions
  structure(Entry, desc="...", interface="AbstractCacheEntry" ) {
    State CacheState,        desc="cache state";
    DataBlock DataBlk,       desc="data for the block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch, desc="Set if this block was prefetched and not yet accessed";
  }

  structure(TBE, desc="...") {
    Addr addr,              desc="Physical address for this TBE";
    State TBEState,        desc="Transient state";
    DataBlock DataBlk,                desc="Buffer for the data block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch,       desc="Set if this was caused by a prefetch";
    int pendingAcks, default="0", desc="number of pending acks";
  }

  # TBE table definition
  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }

  TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";

  # Helper functions
  Tick clockEdge();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);

  # Function to get cache entry (checks both I-cache and D-cache)
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    if(is_valid(L1Dcache_entry)) {
      return L1Dcache_entry;
    }

    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  # Functions to get L1 D-cache and I-cache entries
  Entry getL1DCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    return L1Dcache_entry;
  }

  Entry getL1ICacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  # Function to get the state of a cache line
  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:NP;
  }

  # Function to set the state of a cache line
  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  # Function to get access permission for an address
  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(tbe.TBEState));
      return L1Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(cache_entry.CacheState));
      return L1Cache_State_to_permission(cache_entry.CacheState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  # ... [Additional helper functions]

  # Port definitions for various message types
  out_port(requestL1Network_out, RequestMsg, requestFromL1Cache);
  out_port(responseL1Network_out, ResponseMsg, responseFromL1Cache);
  out_port(unblockNetwork_out, ResponseMsg, unblockFromL1Cache);
  out_port(optionalQueue_out, RubyRequest, optionalQueue);

  # ... [Input ports and their actions]

  # Function to enqueue a prefetch request
  void enqueuePrefetch(Addr address, RubyRequestType type) {
      enqueue(optionalQueue_out, RubyRequest, 1) {
          out_msg.LineAddress := address;
          out_msg.Type := type;
          out_msg.AccessMode := RubyAccessMode:Supervisor;
      }
  }

# MESI_Two_Level_L1Cache.sm (continued)

// ACTIONS

// Action to issue a GETS (read) request
action(a_issueGETS, "a", desc="Issue GETS") {
  peek(mandatoryQueue_in, RubyRequest) {
    enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:GETS;
      out_msg.Requestor := machineID;
      // Determine the L2 cache to send the request to
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                        l2_select_low_bit, l2_select_num_bits, intToID(0)));
      DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
              address, out_msg.Destination);
      out_msg.MessageSize := MessageSizeType:Control;
      out_msg.Prefetch := in_msg.Prefetch;
      out_msg.AccessMode := in_msg.AccessMode;
    }
  }
}

// Action to issue a prefetch GETS request
action(pa_issuePfGETS, "pa", desc="Issue prefetch GETS") {
  // Similar to a_issueGETS, but for prefetch requests
  // ...
}

// Action to issue a GETINSTR (instruction fetch) request
action(ai_issueGETINSTR, "ai", desc="Issue GETINSTR") {
  // Similar to a_issueGETS, but with CoherenceRequestType:GET_INSTR
  // ...
}

// Action to issue a prefetch GETINSTR request
action(pai_issuePfGETINSTR, "pai", desc="Issue GETINSTR for prefetch request") {
  // Similar to ai_issueGETINSTR, but for prefetch requests
  // ...
}

// Action to issue a GETX (write) request
action(b_issueGETX, "b", desc="Issue GETX") {
  peek(mandatoryQueue_in, RubyRequest) {
    enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:GETX;
      out_msg.Requestor := machineID;
      DPRINTF(RubySlicc, "%s\n", machineID);
      // Determine the L2 cache to send the request to
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                        l2_select_low_bit, l2_select_num_bits, intToID(0)));
      DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
              address, out_msg.Destination);
      out_msg.MessageSize := MessageSizeType:Control;
      out_msg.Prefetch := in_msg.Prefetch;
      out_msg.AccessMode := in_msg.AccessMode;
    }
  }
}

// Action to issue a prefetch GETX request
action(pb_issuePfGETX, "pb", desc="Issue prefetch GETX") {
  // Similar to b_issueGETX, but for prefetch requests
  // ...
}

// Action to issue an UPGRADE request (changing from shared to exclusive)
action(c_issueUPGRADE, "c", desc="Issue GETX") {
  // Similar to b_issueGETX, but with CoherenceRequestType:UPGRADE
  // ...
}

// Action to send data to the requestor
action(d_sendDataToRequestor, "d", desc="send data to requestor") {
  peek(requestL1Network_in, RequestMsg) {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(in_msg.Requestor);
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }
}

// Action to send data to L2 cache (for M state downgrade)
action(d2_sendDataToL2, "d2", desc="send data to the L2 cache because of M downgrade") {
  // Similar to d_sendDataToRequestor, but sends to L2 instead
  // ...
}

// Actions dt_sendDataToRequestor_fromTBE and d2t_sendDataToL2_fromTBE
// These are similar to d_sendDataToRequestor and d2_sendDataToL2,
// but they get data from the TBE (Transient Buffer Entry) instead of the cache entry

// Action to send an acknowledgement to the requestor
action(e_sendAckToRequestor, "e", desc="send invalidate ack to requestor (could be L2 or L1)") {
  peek(requestL1Network_in, RequestMsg) {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:ACK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(in_msg.Requestor);
      out_msg.MessageSize := MessageSizeType:Response_Control;
    }
  }
}

// Action to send data to L2 cache (for writeback)
action(f_sendDataToL2, "f", desc="send data to the L2 cache") {
  enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
    assert(is_valid(cache_entry));
    out_msg.addr := address;
    out_msg.Type := CoherenceResponseType:DATA;
    out_msg.DataBlk := cache_entry.DataBlk;
    out_msg.Dirty := cache_entry.Dirty;
    out_msg.Sender := machineID;
    out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                        l2_select_low_bit, l2_select_num_bits, intToID(0)));
    out_msg.MessageSize := MessageSizeType:Writeback_Data;
  }
}

// Action ft_sendDataToL2_fromTBE is similar to f_sendDataToL2,
// but it gets data from the TBE instead of the cache entry

// Action to send an invalidation acknowledgement
action(fi_sendInvAck, "fi", desc="send data to the L2 cache") {
  peek(requestL1Network_in, RequestMsg) {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:ACK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(in_msg.Requestor);
      out_msg.MessageSize := MessageSizeType:Response_Control;
      out_msg.AckCount := 1;
    }
  }
}




}